{"version":3,"file":"index.js","sources":["../src/lib/constants.js","../src/lib/utils.js","../src/lib/core/setters.js","../src/lib/core/getters.js","../src/lib/vuePopulator.js"],"sourcesContent":["export const constants = {\n    // List of chars to check during prettify process\n    PRETTIFY_CHARS_TO_CHECK: ['-', '_'],\n    // Map for the types fallback values on set\n    TYPE_FALLBACK_MAP: {\n        string: '',\n        number: 0,\n        boolean: false,\n        array: [],\n        object: null,\n        undefined,\n    },\n    ARRAY_PROP_TYPE: 'array',\n    OBJECT_PROP_TYPE: 'object',\n};\n\nexport default constants;\n","// Custom imports\nimport { constants } from './constants.js';\n\n/**\n * Returns the first character of a given string\n * @param {String} value\n */\nexport const getStringFirstChar = (value) => {\n    if (!value) return '';\n    return value.charAt(0);\n};\n\n/**\n * Returns the capitalized value of the given value\n * @param {Any} value\n */\nexport const getCapitalizedString = (value) => {\n    if (!value) return '';\n\n    const stringifiedValue = value.toString();\n    return getStringFirstChar(stringifiedValue).toUpperCase() + stringifiedValue.slice(1);\n};\n\n/**\n * Returns the prettiefied value of the given value. It means removing all the dashes and underscores found\n * @param {Any} value\n */\nexport const getPrettifiedString = (value) => {\n    if (!value) return '';\n\n    const stringifiedValue = value.toString();\n    const { PRETTIFY_CHARS_TO_CHECK: prettifyChars } = constants;\n\n    return prettifyChars.reduce((acc, char) => {\n        const firstCharMatch = acc.startsWith(char);\n        const splittedValue = acc.split(char);\n\n        if (firstCharMatch || splittedValue.length !== 1) {\n            splittedValue.forEach((partialValue, index) => {\n                if ((!index && !firstCharMatch) || !partialValue) return;\n                splittedValue[index] = getStringFirstChar(partialValue).toUpperCase() + partialValue.slice(1);\n            });\n        }\n\n        return splittedValue.join('');\n    }, stringifiedValue);\n};\n\n/**\n * Returns the type of the prop given its value\n * @param {any} value\n */\nexport const getPropType = (value) => {\n    return Array.isArray(value) ? constants.ARRAY_PROP_TYPE : typeof value;\n};\n\n/**\n * Returns the fallback value for the prop given its type\n * @param {String} type\n * @param {Object} config\n */\nexport const getFallbackValue = (type, config) => {\n    const fallbackValue = constants.TYPE_FALLBACK_MAP[type];\n\n    // If there's no custom config then return the value\n    if (!config?.overrideFallbackMap) {\n        return fallbackValue;\n    }\n\n    const overridenTypes = Object.keys(config.overrideFallbackMap);\n\n    // If the current type hasn't been override then return the value\n    if (!overridenTypes.includes(type)) {\n        return fallbackValue;\n    }\n\n    return config.overrideFallbackMap[type];\n};\n","// Custom imports\nimport { getCapitalizedString, getPrettifiedString, getPropType, getFallbackValue } from '../utils.js';\n\n/**\n * Create a generic setter given the context and the attribute key\n * @param {VueComponent} context\n * @param {String} key\n * @param {Object} config\n */\nexport const populateSetter = (context, key, config) => {\n    // Prettify the key\n    const prettyKey = getCapitalizedString(getPrettifiedString(key));\n    // Get the type of the prop to generate the fallback value\n    const propType = getPropType(context[key]);\n    const fallbackValue = getFallbackValue(propType, config);\n\n    // Then create the generic setter for the current key\n    context[`set${prettyKey}`] = (newValue = fallbackValue) => (context[key] = newValue);\n};\n","// Custom imports\nimport { constants } from '../constants.js';\nimport { getCapitalizedString, getPrettifiedString, getPropType } from '../utils.js';\n\n/**\n * Create a generic boolean getter function given the context, the name and the attribute key\n * @param {VueComponent} context\n * @param {String} name\n * @param {String} key\n */\nconst getGenericBooleanGetter = (context, name, key) => {\n    Object.defineProperty(context, name, {\n        get() {\n            return !!context[key];\n        },\n    });\n};\n\n/**\n * Create a boolean getter function for an array given the context, the name and the attribute key\n * @param {VueComponent} context\n * @param {String} name\n * @param {String} key\n */\nconst getArrayBooleanGetter = (context, name, key) => {\n    Object.defineProperty(context, name, {\n        get() {\n            return !!context[key]?.length;\n        },\n    });\n};\n\n/**\n * Create a plain getter function given the context, the name, the parent reference and the attribute key\n * @param {VueComponent} context\n * @param {String} name\n * @param {String} parentKey\n * @param {String} key\n */\nconst getNestedObjectGetter = (context, name, parentKey, key) => {\n    Object.defineProperty(context, name, {\n        get() {\n            return context[parentKey][key];\n        },\n    });\n};\n\n/**\n * Create a boolean getter given the context and the attribute key\n * @param {VueComponent} context\n * @param {String} key\n */\nexport const populateBooleanGetter = (context, key) => {\n    // Prettify the key and generate the name of the function\n    const prettyKey = getCapitalizedString(getPrettifiedString(key));\n    const name = `has${prettyKey}`;\n    // Get the type of the prop\n    const propType = getPropType(context[key]);\n\n    if (propType === constants.ARRAY_PROP_TYPE) {\n        // Then create the getter for the array\n        getArrayBooleanGetter(context, name, key);\n        return;\n    }\n\n    // Create the generic boolean getter\n    getGenericBooleanGetter(context, name, key);\n};\n\n/**\n * Create a series of getters as a quick access to the object properties given the context and the attribute key\n * @param {VueComponent} context\n * @param {String} key\n */\nexport const populateQuickAccessGetters = (context, key) => {\n    // Prettify the key and extract the target keys\n    const prettyKey = getPrettifiedString(key);\n    const keys = Object.keys(context[key]);\n\n    keys.forEach((subKey) => {\n        // Prettify the subkey and generate the name of the function\n        const prettySubKey = getCapitalizedString(getPrettifiedString(subKey));\n        const name = `${prettyKey}${prettySubKey}`;\n        // Get the type of the prop\n        const value = context[key][subKey];\n        const propType = getPropType(value);\n\n        // Create the getter for the nested attribute of the object\n        getNestedObjectGetter(context, name, key, subKey);\n\n        if (value && propType === constants.OBJECT_PROP_TYPE) {\n            populateQuickAccessGetters(context, name);\n        }\n    });\n};\n","// Core imports\nimport { populateSetter } from './core/setters.js';\nimport { populateBooleanGetter, populateQuickAccessGetters } from './core/getters.js';\n// Custom imports\nimport { constants } from './constants.js';\nimport { getPropType } from './utils.js';\n\n// Default export for the Vue Populator\nconst vuePopulator = (context, config) => {\n    const { $data: data } = context ?? {};\n    if (!data || typeof data !== 'object' || Array.isArray(data)) return;\n\n    // Loop over the data properties of the Vue context\n    Object.keys(data).forEach((key) => {\n        const value = context[key];\n        const propType = getPropType(value);\n\n        // Create the setter for the current key\n        populateSetter(context, key, config);\n\n        // Create the boolean getter for the current key\n        populateBooleanGetter(context, key);\n\n        if (value && propType === constants.OBJECT_PROP_TYPE) {\n            populateQuickAccessGetters(context, key);\n        }\n    });\n};\n\nexport default vuePopulator;\n"],"names":["constants","PRETTIFY_CHARS_TO_CHECK","TYPE_FALLBACK_MAP","string","number","boolean","array","object","undefined","ARRAY_PROP_TYPE","OBJECT_PROP_TYPE","getStringFirstChar","value","charAt","getCapitalizedString","stringifiedValue","toString","toUpperCase","slice","getPrettifiedString","prettifyChars","reduce","acc","char","firstCharMatch","startsWith","splittedValue","split","length","forEach","partialValue","index","join","getPropType","Array","isArray","populateSetter","context","key","config","prettyKey","fallbackValue","type","overrideFallbackMap","Object","keys","includes","getFallbackValue","newValue","populateBooleanGetter","name","defineProperty","get","getGenericBooleanGetter","getArrayBooleanGetter","populateQuickAccessGetters","subKey","prettySubKey","propType","parentKey","getNestedObjectGetter","$data","data"],"mappings":"uDAAO,MAAMA,EAAY,CAErBC,wBAAyB,CAAC,IAAK,KAE/BC,kBAAmB,CACfC,OAAQ,GACRC,OAAQ,EACRC,SAAS,EACTC,MAAO,GACPC,OAAQ,KACRC,eAAAA,GAEJC,gBAAiB,QACjBC,iBAAkB,UCNTC,EAAsBC,GAC1BA,EACEA,EAAMC,OAAO,GADD,GAQVC,EAAwBF,IACjC,IAAKA,EAAO,MAAO,GAEnB,MAAMG,EAAmBH,EAAMI,WAC/B,OAAOL,EAAmBI,GAAkBE,cAAgBF,EAAiBG,MAAM,IAO1EC,EAAuBP,IAChC,IAAKA,EAAO,MAAO,GAEnB,MAAMG,EAAmBH,EAAMI,YACvBf,wBAAyBmB,GAAkBpB,EAEnD,OAAOoB,EAAcC,QAAO,CAACC,EAAKC,KAC9B,MAAMC,EAAiBF,EAAIG,WAAWF,GAChCG,EAAgBJ,EAAIK,MAAMJ,GAShC,OAPIC,GAA2C,IAAzBE,EAAcE,SAChCF,EAAcG,SAAQ,CAACC,EAAcC,MAC3BA,GAAUP,IAAoBM,IACpCJ,EAAcK,GAASpB,EAAmBmB,GAAcb,cAAgBa,EAAaZ,MAAM,OAI5FQ,EAAcM,KAAK,MAC3BjB,IAOMkB,EAAerB,GACjBsB,MAAMC,QAAQvB,GAASZ,EAAUS,uBAAyBG,EC5CxDwB,EAAiB,CAACC,EAASC,EAAKC,KAEzC,MAAMC,EAAY1B,EAAqBK,EAAoBmB,IAGrDG,ED+CsB,EAACC,EAAMH,KACnC,MAAME,EAAgBzC,EAAUE,kBAAkBwC,GAGlD,OAAKH,GAAQI,qBAIUC,OAAOC,KAAKN,EAAOI,qBAGtBG,SAASJ,GAItBH,EAAOI,oBAAoBD,GAVvBD,GCpDWM,CADLd,EAAYI,EAAQC,IACYC,GAGjDF,EAAQ,MAAMG,KAAe,CAACQ,EAAWP,IAAmBJ,EAAQC,GAAOU,GCmClEC,EAAwB,CAACZ,EAASC,KAE3C,MACMY,EAAO,MADKpC,EAAqBK,EAAoBmB,MAG1CL,EAAYI,EAAQC,MAEpBtC,EAAUS,gBAjDC,EAAC4B,EAASa,EAAMZ,KAC5CM,OAAOO,eAAed,EAASa,EAAM,CACjCE,IAAG,MACUf,EAAQC,MAqDzBe,CAAwBhB,EAASa,EAAMZ,GA1Cb,EAACD,EAASa,EAAMZ,KAC1CM,OAAOO,eAAed,EAASa,EAAM,CACjCE,IAAG,MACUf,EAAQC,IAAMV,UAkC3B0B,CAAsBjB,EAASa,EAAMZ,IAahCiB,EAA6B,CAAClB,EAASC,KAEhD,MAAME,EAAYrB,EAAoBmB,GACzBM,OAAOC,KAAKR,EAAQC,IAE5BT,SAAS2B,IAEV,MAAMC,EAAe3C,EAAqBK,EAAoBqC,IACxDN,EAAO,GAAGV,IAAYiB,IAEtB7C,EAAQyB,EAAQC,GAAKkB,GACrBE,EAAWzB,EAAYrB,GA9CP,EAACyB,EAASa,EAAMS,EAAWrB,KACrDM,OAAOO,eAAed,EAASa,EAAM,CACjCE,IAAG,IACQf,EAAQsB,GAAWrB,MA8C9BsB,CAAsBvB,EAASa,EAAMZ,EAAKkB,GAEtC5C,GAAS8C,IAAa1D,EAAUU,kBAChC6C,EAA2BlB,EAASa,uBCnF3B,CAACb,EAASE,KAC3B,MAAQsB,MAAOC,GAASzB,GAAW,GAC9ByB,GAAwB,iBAATA,IAAqB5B,MAAMC,QAAQ2B,IAGvDlB,OAAOC,KAAKiB,GAAMjC,SAASS,IACvB,MAAM1B,EAAQyB,EAAQC,GAChBoB,EAAWzB,EAAYrB,GAG7BwB,EAAeC,EAASC,EAAKC,GAG7BU,EAAsBZ,EAASC,GAE3B1B,GAAS8C,IAAa1D,EAAUU,kBAChC6C,EAA2BlB,EAASC"}