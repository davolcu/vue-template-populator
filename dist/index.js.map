{"version":3,"file":"index.js","sources":["../src/lib/constants.js","../src/lib/utils.js","../src/lib/core/setters.js","../src/lib/core/getters.js","../src/lib/vuePopulator.js"],"sourcesContent":["export const constants = {\n    // List of chars to check during prettify process\n    PRETTIFY_CHARS_TO_CHECK: ['-', '_'],\n    // Map for the types fallback values on set\n    TYPE_FALLBACK_MAP: {\n        string: '',\n        number: 0,\n        boolean: false,\n        array: [],\n        object: null,\n        undefined,\n    },\n    ARRAY_PROP_TYPE: 'array',\n};\n\nexport default constants;\n","import { constants } from './constants.js';\n\n/**\n * Returns the first character of a given string\n * @param {String} value\n */\nexport const getStringFirstChar = (value) => {\n    if (!value) return '';\n    return value.charAt(0);\n};\n\n/**\n * Returns the capitalized value of the given value\n * @param {Any} value\n */\nexport const getCapitalizedString = (value) => {\n    if (!value) return '';\n\n    const stringifiedValue = value.toString();\n    return getStringFirstChar(stringifiedValue).toUpperCase() + stringifiedValue.slice(1);\n};\n\n/**\n * Returns the prettiefied value of the given value. It means removing all the dashes and underscores found\n * @param {Any} value\n */\nexport const getPrettifiedString = (value) => {\n    if (!value) return '';\n\n    const stringifiedValue = value.toString();\n    const { PRETTIFY_CHARS_TO_CHECK: prettifyChars } = constants;\n\n    return prettifyChars.reduce((acc, char) => {\n        const firstCharMatch = acc.startsWith(char);\n        const splittedValue = acc.split(char);\n\n        if (firstCharMatch || splittedValue.length === 1) {\n            splittedValue.forEach((partialValue, index) => {\n                if ((!index && !firstCharMatch) || !partialValue) return;\n                splittedValue[index] = getStringFirstChar(partialValue).toUpperCase() + partialValue.slice(1);\n            });\n        }\n\n        return splittedValue.join('');\n    }, stringifiedValue);\n};\n\n/**\n * Returns the type of the prop given its value\n * @param {any} value\n */\nexport const getPropType = (value) => {\n    return Array.isArray(value) ? constants.ARRAY_PROP_TYPE : typeof value;\n};\n\n/**\n * Returns the fallback value for the prop given its type\n * @param {String} type\n * @param {Object} config\n */\nexport const getFallbackValue = (type, config) => {\n    const fallbackValue = constants.TYPE_FALLBACK_MAP[type];\n\n    // If there's no custom config then return the value\n    if (!config?.overrideFallbackMap) {\n        return fallbackValue;\n    }\n\n    const overridenTypes = Object.keys(config.overrideFallbackMap);\n\n    // If the current type hasn't been override then return the value\n    if (!overridenTypes.includes(type)) {\n        return fallbackValue;\n    }\n\n    return overridenTypes[type];\n};\n","import { getCapitalizedString, getPrettifiedString, getPropType, getFallbackValue } from '../utils.js';\n\n/**\n * Create a generic setter given the context and the attribute key\n * @param {VueComponent} context\n * @param {String} key\n * @param {Object} config\n */\nexport const populateSetter = (context, key, config) => {\n    // Prettify the key\n    const prettyKey = getCapitalizedString(getPrettifiedString(key));\n    // Get the type of the prop to generate the fallback value\n    const propType = getPropType(context[key]);\n    const fallbackValue = getFallbackValue(propType, config);\n\n    // Then create the generic setter for the current key\n    context[`set${prettyKey}`] = (newValue = fallbackValue) => (context[key] = newValue);\n};\n","import { constants } from '../constants.js';\nimport { getCapitalizedString, getPrettifiedString, getPropType } from '../utils.js';\n\n/**\n * Create a generic boolean getter function given the context, the name and the attribute key\n * @param {VueComponent} context\n * @param {String} name\n * @param {String} key\n */\nconst getGenericBooleanGetter = (context, name, key) => {\n    Object.defineProperty(context, name, {\n        get() {\n            return !!context[key];\n        },\n    });\n};\n\n/**\n * Create a boolean getter function for an array given the context, the name and the attribute key\n * @param {VueComponent} context\n * @param {String} name\n * @param {String} key\n */\nconst getArrayBooleanGetter = (context, name, key) => {\n    Object.defineProperty(context, name, {\n        get() {\n            return !!context[key]?.length;\n        },\n    });\n};\n\n/**\n * Create a boolean getter given the context and the attribute key\n * @param {VueComponent} context\n * @param {String} key\n */\nexport const populateBooleanGetter = (context, key) => {\n    // Prettify the key and generate the name of the function\n    const prettyKey = getCapitalizedString(getPrettifiedString(key));\n    const name = `has${prettyKey}`;\n    // Get the type of the prop\n    const propType = getPropType(context[key]);\n\n    if (propType === constants.ARRAY_PROP_TYPE) {\n        // Then create the getter for the array\n        getArrayBooleanGetter(context, name, key);\n        return;\n    }\n\n    // Create the generic boolean getter\n    getGenericBooleanGetter(context, name, key);\n};\n","import { populateSetter } from './core/setters.js';\nimport { populateBooleanGetter } from './core/getters.js';\n\n// Default export for the Vue Populator\nconst vuePopulator = (context, config) => {\n    const { $data: data } = context ?? {};\n    if (!data || typeof data !== 'object' || Array.isArray(data)) return;\n\n    // Loop over the data properties of the Vue context\n    Object.keys(data).forEach((key) => {\n        // Create the setter for the current key\n        populateSetter(context, key, config);\n        // Create the boolean getter for the current key\n        populateBooleanGetter(context, key);\n    });\n};\n\nexport default vuePopulator;\n"],"names":["constants","PRETTIFY_CHARS_TO_CHECK","TYPE_FALLBACK_MAP","string","number","boolean","array","object","undefined","ARRAY_PROP_TYPE","getStringFirstChar","value","charAt","getCapitalizedString","stringifiedValue","toString","toUpperCase","slice","getPrettifiedString","prettifyChars","reduce","acc","char","firstCharMatch","startsWith","splittedValue","split","length","forEach","partialValue","index","join","getPropType","Array","isArray","populateSetter","context","key","config","prettyKey","fallbackValue","type","overrideFallbackMap","overridenTypes","Object","keys","includes","getFallbackValue","newValue","populateBooleanGetter","name","defineProperty","get","getGenericBooleanGetter","getArrayBooleanGetter","$data","data"],"mappings":"uDAAO,MAAMA,EAAY,CAErBC,wBAAyB,CAAC,IAAK,KAE/BC,kBAAmB,CACfC,OAAQ,GACRC,OAAQ,EACRC,SAAS,EACTC,MAAO,GACPC,OAAQ,KACRC,eAAAA,GAEJC,gBAAiB,SCNRC,EAAsBC,GAC1BA,EACEA,EAAMC,OAAO,GADD,GAQVC,EAAwBF,IACjC,IAAKA,EAAO,MAAO,GAEnB,MAAMG,EAAmBH,EAAMI,WAC/B,OAAOL,EAAmBI,GAAkBE,cAAgBF,EAAiBG,MAAM,IAO1EC,EAAuBP,IAChC,IAAKA,EAAO,MAAO,GAEnB,MAAMG,EAAmBH,EAAMI,YACvBd,wBAAyBkB,GAAkBnB,EAEnD,OAAOmB,EAAcC,QAAO,CAACC,EAAKC,KAC9B,MAAMC,EAAiBF,EAAIG,WAAWF,GAChCG,EAAgBJ,EAAIK,MAAMJ,GAShC,OAPIC,GAA2C,IAAzBE,EAAcE,SAChCF,EAAcG,SAAQ,CAACC,EAAcC,MAC3BA,GAAUP,IAAoBM,IACpCJ,EAAcK,GAASpB,EAAmBmB,GAAcb,cAAgBa,EAAaZ,MAAM,OAI5FQ,EAAcM,KAAK,MAC3BjB,IAOMkB,EAAerB,GACjBsB,MAAMC,QAAQvB,GAASX,EAAUS,uBAAyBE,EC5CxDwB,EAAiB,CAACC,EAASC,EAAKC,KAEzC,MAAMC,EAAY1B,EAAqBK,EAAoBmB,IAGrDG,ED+CsB,EAACC,EAAMH,KACnC,MAAME,EAAgBxC,EAAUE,kBAAkBuC,GAGlD,IAAKH,GAAQI,oBACT,OAAOF,EAGX,MAAMG,EAAiBC,OAAOC,KAAKP,EAAOI,qBAG1C,OAAKC,EAAeG,SAASL,GAItBE,EAAeF,GAHXD,GC3DWO,CADLf,EAAYI,EAAQC,IACYC,GAGjDF,EAAQ,MAAMG,KAAe,CAACS,EAAWR,IAAmBJ,EAAQC,GAAOW,GCoBlEC,EAAwB,CAACb,EAASC,KAE3C,MACMa,EAAO,MADKrC,EAAqBK,EAAoBmB,MAG1CL,EAAYI,EAAQC,MAEpBrC,EAAUS,gBAlCC,EAAC2B,EAASc,EAAMb,KAC5CO,OAAOO,eAAef,EAASc,EAAM,CACjCE,IAAG,MACUhB,EAAQC,MAsCzBgB,CAAwBjB,EAASc,EAAMb,GA3Bb,EAACD,EAASc,EAAMb,KAC1CO,OAAOO,eAAef,EAASc,EAAM,CACjCE,IAAG,MACUhB,EAAQC,IAAMV,UAmB3B2B,CAAsBlB,EAASc,EAAMb,oBCzCxB,CAACD,EAASE,KAC3B,MAAQiB,MAAOC,GAASpB,GAAW,GAC9BoB,GAAwB,iBAATA,IAAqBvB,MAAMC,QAAQsB,IAGvDZ,OAAOC,KAAKW,GAAM5B,SAASS,IAEvBF,EAAeC,EAASC,EAAKC,GAE7BW,EAAsBb,EAASC"}